use uo;
use os;

include ":spawnsystem:include/groups";
include ":spawnsystem:include/realms";
include ":spawnsystem:include/regions";
include ":spawnsystem:include/errors";

program FirstRun()
	var start_cfg := ReadConfigFile(":spawnsystem:config/firstrun");
	if ( start_cfg.errortext )
		SSErrorReport(start_cfg.errortext, SPAWN_ERROR_SYSLOG);
		return 0;
	endif

	var realm_list := start_cfg["Realms"];
	if ( realm_list.errortext)
		SSErrorReport(start_cfg.errortext, SPAWN_ERROR_SYSLOG);
		return 0;
	endif

	foreach realm_name in (GetConfigStringArray(realm_list, "Realm"))
		SysLog("Setting up spawner realm ("+realm_name+")");
		var success := SetupRealm(realm_name, start_cfg);
		
		if ( success )
			SysLog("Spawn realm ("+realm_name+") setup... okay.");
		else
			SysLog("Spawn realm ("+realm_name+") setup... failed!");
		endif
		
		sleepms(2);
	endforeach
	
	UnloadConfigFile(":spawnsystem:config/firstrun");

	return 1;
endprogram

function SetupRealm(realm_name, start_cfg)
	var realm_info := start_cfg[realm_name];
	if ( realm_info.errortext )
		SSErrorReport("No cfg elem for realm ("+realm_name+") -> "+realm_info.errortext, SPAWN_ERROR_SYSLOG);
		return 0;
	endif
	
	SSAddRealm(realm_name);

	foreach region_name in (GetConfigStringArray(realm_info, "Region"))
		SysLog("Setting up spawn region ("+region_name+")");
		var success := SetupRegion(region_name, realm_name, start_cfg);
		
		if ( success )
			SSAddRegionToRealm(realm_name, region_name);
		endif
		
		if ( success )
			SysLog("Spawn region ("+region_name+") setup... okay.");
		else
			SysLog("Spawn region ("+region_name+") setup... failed!");
		endif
		
		sleepms(2);
	endforeach

	return 1;
endfunction

function SetupRegion(region_name, realm_name, start_cfg)
	var region_info := start_cfg[region_name];
	if ( region_info.errortext )
		SSErrorReport("No cfg elem for region ("+region_name+") -> "+region_info.errortext, SPAWN_ERROR_SYSLOG);
		return 0;
	endif

	
	SSAddRegion(region_name, realm_name);
	var coords := SplitWords(region_info.Coordinates);
	SSSetRegionCoordinates(region_name, coords[1], coords[2], coords[3], coords[4]);

	foreach group_name in (GetConfigStringArray(region_info, "Group"))
		group_name := SplitWords(group_name);
		var max_amt := CInt(group_name[2]);
		var spawn_wait := CInt(group_name[3]);
		group_name := group_name[1];
		
		var success := SetupGroup(group_name, start_cfg);
		
		if ( success )
			success := SSAddGroupToRegion(region_name, group_name, max_amt, spawn_wait, 1);
		endif
		if ( success )
			SysLog("Adding group ("+group_name+") to region ("+region_name+")... okay.");
		else
			SysLog("Adding group ("+group_name+") to region ("+region_name+")... failed!");
		endif
		
		sleepms(2);
	endforeach

	return 1;
endfunction

function SetupGroup(group_name, start_cfg)
	if ( SSGetGroupDataElem(group_name) )
		//Group has already been set up.
		return 1;
	endif
	
	SysLog("Setting up spawner group ("+group_name+")");
	
	var group_info := start_cfg[group_name];
	if ( group_info.errortext )
		SSErrorReport("No cfg elem for group ("+group_name+") -> "+group_info.errortext, SPAWN_ERROR_SYSLOG);
		return 0;
	elseif ( !group_info.Engine )
		SSErrorReport("No valid engine name was set for group ("+group_name+")", SPAWN_ERROR_SYSLOG);
		return 0;
	endif
	
	SSAddGroup(group_name, group_info.Engine);
	
	foreach entry in (GetConfigStringArray(group_info, "Entry"))
		SSAddEntryToGroup(group_name, entry);
		sleepms(2);
	endforeach
	
	return 1;
endfunction

/*
function Test_WipeSpawner()
	foreach realm_name in SSGetRealmNames()
		Print("* Erasing Realm ("+realm_name+") ["+SSRemoveRealm(realm_name)+"]");
		sleepms(2);
	endforeach
	
	foreach region_name in SSGetRegionNames()
		Print("* Erasing Region ("+region_name+") ["+SSRemoveRegion(region_name)+"]");
		sleepms(2);
	endforeach
	
	foreach group_name in SSGetGroupNames()
		Print("* Erasing Group ("+group_name+") ["+SSRemoveGroup(group_name)+"]");
		sleepms(2);
	endforeach
	
	sleep(1);
	
	return 1;
endfunction
*/