/* $Id$
 *
 */
use uo;
use os;

include ":attributes:attributes";
include ":magery:spells";
include ":itemutils:objtype";
include ":coords:isValidLoc";
include ":runebook:runebookFunctions";
include ":containers:containers";
include ":itemutils:itemdesc";
include "include/sounds";

program SpellScript(params)
	var who := params[1];
	var runebook_info := params[2].targ;
	//var info := params[2];
	params := 0; // No longer needed

	if( TypeOf(runebook_info) == "Array" )
		RunebookGate(who, runebook_info);
		return 1;
	endif

	var prompt := "Select an object to gate from.";
	var recall_rune := MS_Target(who, 0, prompt, TGTOPT_CHECK_LOS+TGTOPT_NEUTRAL);
	if( (recall_rune.objtype != UOBJ_RUNE) && (recall_rune.objtype != 0x6100))
		SendSysMessage(who, "You can only cast that on a recall rune or runebook.");
		return 0;
	endif
	if( !ReserveItem(recall_rune) )
		return 0;
	endif

	if( GetObjProperty(recall_rune, "Vendored") )
		SendSysMessage(who, "You cannot recall off of runes on a vendor.");
		return 0;
	endif

	var rune_settings;
	case(recall_rune.objtype)
		UOBJ_RUNE: rune_settings := recall_rune.GetDestination();
		0x6100: rune_settings := GetObjProperty(recall_rune, "Destination");
	endcase
	if( TypeOf(rune_settings) != "Struct" )
		SendSysMessage(who, "That item is not marked.");
		return 0;
	endif

	var tox := CInt(rune_settings.x);
	var toy := CInt(rune_settings.y);
	var toz := CInt(rune_settings.z);
	var torealm :=  rune_settings.realm;
	if(!torealm)
		torealm := "britannia";
	endif

	if( !isValidLoc(tox,toy,torealm) )
		SendSysMessage(who, "Invalid recall location.");
		if( recall_rune.objtype == 0x6100 )
			RemoveRunebookDefault(recall_rune);
			return 0;
		else
			DestroyItem(recall_rune);
			return 0;
		endif
	endif

	PlaySoundEffect(who, 0x210);

	if( (who.x >= 5120) && (who.x <= 5375) && (who.y >= 0) && (who.y <= 255) )
		SendSysMessage(who, "Your spell fails and consumes the rune!");
		if(recall_rune.objtype == UOBJ_RUNE)
			DestroyItem(recall_rune);
		elseif(recall_rune.objtype == 0x6100)
			RemoveRunebookDefault(recall_rune);
		endif
		return 0;
	endif

	var signs := ListItemsNearLocationOfType( tox, toy, toz, 30, 0x7060, torealm);
	foreach sign in signs
		var infoarr := GetObjProperty(sign, "homeinfo");
		if( infoarr )
			if( (tox >= infoarr[2]) && (tox <= infoarr[4]) && (toy >= infoarr[3]) && (toy <= infoarr[5]) )
				SendSysMessage(who, "Something is blocking the location.");
				return 0;
				break;
			endif
		endif
	endforeach

	var multicheck := CreateItemAtLocation(1, 1, 0, 0xeed, 1, torealm);
	multicheck.invisible := 1;
	if( !MoveItemToLocation(multicheck, tox, toy, toz, MOVEITEM_NORMAL) )
		SendSysMessage(who, "Something is blocking the location.");
		if(recall_rune.objtype == UOBJ_RUNE)
			DestroyItem(recall_rune);
		elseif(recall_rune.objtype == 0x6100)
			RemoveRunebookDefault(recall_rune);
		endif
		return 0;
	endif
	if(multicheck.multi)
		SendSysMessage(who,"Something is blocking the location.");
		if(recall_rune.objtype == UOBJ_RUNE)
			DestroyItem(recall_rune);
		elseif(recall_rune.objtype == 0x6100)
			RemoveRunebookDefault(recall_rune);
		endif
		return 0;
	endif
	DestroyItem(multicheck);

	var wx := who.x;
	var wy := who.y;
	var wz := who.z;
	PlayStationaryEffect( wx, wy, wz, 6899, 1, 30, 0, who.realm );
	PlayStationaryEffect( tox, toy, toz, 6899, 1, 30, 0, torealm );
	sleepms(2800);
	set_critical( 1 );
	var gate1 := CreateItemAtLocation( wx, wy, wz, UOBJ_BLUE_MOONGATE, 1, who.realm );
	gate1.movable := 0;
	var gate2 := CreateItemAtLocation( tox, toy, toz, UOBJ_BLUE_MOONGATE, 1, torealm );
	gate2.movable := 0;
	if( !gate1 )
		DestroyItem(gate2);
		SendSysMessage(who, "Something is interfering with the spell.");
		return 0;
	endif
	if( !gate2 )
		DestroyItem(gate1);
		SendSysMessage(who, "Something is interfering with the spell.");
		return 0;
	endif
	set_critical(0);
	var dest := dictionary{ "x" -> gate2.x, "y" -> gate2.y, "z" -> gate2.z, "realm" -> gate2.realm};
	SetObjProperty( gate1, "Destination", dest );
	dest := dictionary{ "x" -> gate1.x, "y" -> gate1.y, "z" -> gate1.z, "realm" -> gate1.realm};
	SetObjProperty( gate2, "Destination", dest );
	Detach();
	sleep(30);
	set_critical(1);
	DestroyItem( gate1 );
	DestroyItem( gate2 );
	set_critical(0);
	return 1;
endprogram

function RemoveRunebookDefault(runebook)
	var tox := CInt(GetObjProperty( runebook, "x" ));
	var toy := CInt(GetObjProperty( runebook, "y" ));
	var toz := CInt(GetObjProperty( runebook, "z" ));
	var torealm := GetObjProperty( runebook, "realm" );
	var rune_list := GetRuneList(runebook);

	foreach rune_entry in rune_list
		if( (Cint(rune_list.X) == tox) && (Cint(rune_list.Y) == toy) && (Cint(rune_list.Z) == toz) && (Cint(rune_list.Realm) == torealm) )
			rune_list.Erase(rune_entry);
		endif
	endforeach

	SetObjProperty(runebook, "%RuneList%", rune_list);
	EraseObjProperty(runebook, "x");
	EraseObjProperty(runebook, "y");
	EraseObjProperty(runebook, "z");
	EraseObjProperty(runebook, "realm");
	return 1;
endfunction


function RemoveRunebookEntry(runebook, rune_info)
	var tox := CInt(rune_info.X);
	var toy := CInt(rune_info.Y);
	var toz := CInt(rune_info.Z);
	var torealm :=  rune_info.Realm;
	var rune_list := GetRuneList(runebook);

	foreach rune_entry in rune_list
		if( (Cint(rune_list.X) == tox) && (Cint(rune_list.Y) == toy) && (Cint(rune_list.Z) == toz) && (Cint(rune_list.Realm) == torealm) )
			rune_list.Erase(rune_entry);
		endif
	endforeach

	SetObjProperty(runebook, "%RuneList%", rune_list);
	EraseObjProperty(runebook, "x");
	EraseObjProperty(runebook, "y");
	EraseObjProperty(runebook, "z");
	EraseObjProperty(runebook, "realm");
	return 1;
endfunction


function RunebookGate(who, runebook_info)
	var runebook := runebook_info[1];
	var rune_info := runebook_info[2];

	if( !ReserveItem(runebook) )
		return 0;
	endif

	var spell_elem := MS_GetSpellsCfgElem(52);
	if ( !CheckReagents(who, spell_elem, 0) )
		FailSpell(who);
		return 0;
	endif

	if( GetObjProperty(runebook, "Vendored") )
		SendSysMessage(who, "You cannot recall off of runebooks on a vendor.");
		return 0;
	endif

	if( TypeOf(rune_info) != "Struct" )
		SendSysMessage(who, "That item is not marked.");
		return 0;
	endif

	var tox := CInt(rune_info.x);
	var toy := CInt(rune_info.y);
	var toz := CInt(rune_info.z);
	var torealm :=  rune_info.realm;
	if(!torealm)
		torealm := "britannia";
	endif

	if( !isValidLoc(tox,toy,torealm) )
		SendSysMessage(who, "Invalid recall location.");
		RemoveRunebookEntry(runebook, rune_info);
		return 0;
	endif

	PlaySoundEffect(who, 0x210);

	if( (who.x >= 5120) && (who.x <= 5375) && (who.y >= 0) && (who.y <= 255) )
		SendSysMessage(who, "Your spell fails and consumes the rune!");
		RemoveRunebookEntry(runebook, rune_info);
		return 0;
	endif

	var signs := ListItemsNearLocationOfType( tox, toy, toz, 30, 0x7060, torealm);
	foreach sign in signs
		var infoarr := GetObjProperty(sign, "homeinfo");
		if( infoarr )
			if( (tox >= infoarr[2]) && (tox <= infoarr[4]) && (toy >= infoarr[3]) && (toy <= infoarr[5]) )
				SendSysMessage(who, "Something is blocking the location.");
				return 0;
				break;
			endif
		endif
	endforeach

	var multicheck := CreateItemAtLocation(1, 1, 0, 0xeed, 1, torealm);
	multicheck.invisible := 1;
	if( !MoveItemToLocation(multicheck, tox, toy, toz, MOVEITEM_NORMAL) )
		SendSysMessage(who, "Something is blocking the location.");
		return 0;
	endif
	if(multicheck.multi)
		SendSysMessage(who,"A house is blocking the location.");
		RemoveRunebookEntry(runebook, rune_info);
		return 0;
	endif
	DestroyItem(multicheck);

	var wx := who.x;
	var wy := who.y;
	var wz := who.z;
	PlayStationaryEffect( wx, wy, wz, 6899, 1, 30, 0, who.realm );
	PlayStationaryEffect( tox, toy, toz, 6899, 1, 30, 0, torealm );
	sleepms(2800);
	set_critical( 1 );
	var gate1 := CreateItemAtLocation( wx, wy, wz, UOBJ_BLUE_MOONGATE, 1, who.realm );
	gate1.movable := 0;
	var gate2 := CreateItemAtLocation( tox, toy, toz, UOBJ_BLUE_MOONGATE, 1, torealm );
	gate2.movable := 0;
	if( !gate1 )
		DestroyItem(gate2);
		SendSysMessage(who, "Something is interfering with the spell.");
		return 0;
	endif
	if( !gate2 )
		DestroyItem(gate1);
		SendSysMessage(who, "Something is interfering with the spell.");
		return 0;
	endif
	set_critical(0);
	var dest := dictionary{ "x" -> gate2.x, "y" -> gate2.y, "z" -> gate2.z, "realm" -> gate2.realm};
	SetObjProperty( gate1, "Destination", dest );
	dest := dictionary{ "x" -> gate1.x, "y" -> gate1.y, "z" -> gate1.z, "realm" -> gate1.realm};
	SetObjProperty( gate2, "Destination", dest );
	Detach();
	sleep(30);
	set_critical(1);
	DestroyItem( gate1 );
	DestroyItem( gate2 );
	set_critical(0);
	return 1;
endfunction


function CheckReagents(who, byref spell_elem, scroll)
	if ( who.npctemplate )
		// NPCs don't need reagents to cast.
		return 1;
	elseif ( scroll.isA(POLCLASS_ITEM) )
		return SubtractAmount(scroll, 1);
	elseif ( scroll == 1 )
		// Added scroll/1 check for passing 1 to override reg
		// and scroll check. IE: runebooks, wands, etc.
		return 1;
	endif

	var reagent_costs := GetConfigStringDictionary(spell_elem, "RegCost");

	// Before consuming, verify that there is enough of everything.
	foreach amount in ( reagent_costs )
		amount := CInt(amount);
		if ( !amount )
			amount := 1;
		endif
		var objtype := GetObjTypeByName(_amount_iter);

		if ( AmountInContainer(who.backpack, objtype) < amount )
			SendSysMessage(who, "You do not have enough "+GetObjTypeDesc(objtype, (amount>1)));
			return 0;
		endif
		sleepms(2);
	endforeach
	// Consume reagents - CInt() and < 1 checks already done in previous loop.
	// Foreach is a pointer!
	foreach amount in ( reagent_costs )
		ConsumeSubstance(who.backpack, GetObjTypeByName(_amount_iter), amount);
		sleepms(2);
	endforeach

	return 1;
endfunction


function FailSpell(who)
	// Simple function for handling effects when a caster
	// fails the casting.
	who.frozen := 0;
	EraseObjProperty(who, "#medding");
	PlayObjectCenteredEffect(who, GFX_SPELL_FAIL, 5, 50);
	PlaySoundEffect(who, SFX_SPELL_FAIL);

	return 1;
endfunction
