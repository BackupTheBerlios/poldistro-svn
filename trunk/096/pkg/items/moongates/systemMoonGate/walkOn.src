/* $Id$
 *
 */

use uo;
use os;
use polsys;

include ":gumps:gumps";
include ":gumps:gumps_ex";
include ":moongates:moongate";

program walkOnScript(mobile, tile)
	if ( mobile.npctemplate )
		return 0;
	elseif ( JustTeleported(mobile) )
		return 0;
	endif
	
	var gump := tile.GetGump();
	var input := GFSendGump(mobile, gump);
	
	if ( !input[MG_OKAY_BTN] )
		SendSysMessage(mobile, "Cancelled.");
		return 0;
	elseif ( Distance(mobile, tile) > 1 )
		SendSysMessage(mobile, "No longer close enough to the moongate.");
		return 0;
	endif
	
	var select := 0;
	foreach key in ( input.Keys )
		if ( key >= MG_LOCATION_START )
			select := key-MG_LOCATION_START;
			break;
		endif
		sleepms(2);
	endforeach
	
	// Not too happy with how I designed this part. - Austin
	// Should probably save a list in a datafile and directly access it by the 'select' variable.
	var config := ReadConfigFile(":moongates:config/moongate");
	var btn_id := 1;
	foreach realm in ( Realms() )
		realm := realm; // To avoid a compiler warning.
		var cfg_elem := config[_realm_iter];
		foreach entry in ( GetConfigStringDictionary(cfg_elem, "Town") )
			if ( btn_id == select )
				var coords := SplitWords(entry);
				var result := MoveObjectToLocation(mobile, CInt(coords[1]), CInt(coords[2]), CInt(coords[3]), _realm_iter, MOVEOBJECT_NORMAL);				
				SetObjProperty(mobile, "#Teleported", ReadMillisecondClock());
				if ( result.errortext )
					SendSysMessage(mobile, "Unable to move ->"+result.errortext);
				endif
				return 1;
			endif
			btn_id := btn_id+1;
		endforeach
		sleepms(2);
	endforeach
	
	return 0;
endprogram

function JustTeleported(mobile)
	var tele_time := CInt(GetObjProperty(mobile, "#Teleported"));
	if ( tele_time > ReadMillisecondClock()-500 )
		// Mobile just teleported. Too soon to teleport again.
		return 1;
	else
		// Safe to teleport the mobile
		return 0;
	endif
endfunction
