/*
 * $Id$
 *
 * Purpose
 *
 * Presents information about a mobile.
 *
 */

use uo;
use os;

include ":attributes:attributes";
include ":brainAI:npcUtil";
include ":gumps:gumps";
include ":gumps:gumpprompt";
include ":gumps:requestgump";
include ":gumps:yesno";
include ":containers:storageAreas";
include ":combat:weaponInfo";
include "include/arrays";

CONST START_Y	:= 55;
CONST END_Y	:= 410;

unload_scripts("");

var priv_names := array
{
	"ignoredoors", "seeinvisitems", "seehidden", "seeghosts",
	"renameany", "moveany", "losany", "invul", "hearghosts",
	"dblclickany", "clotheany", "freemove"
};

// Storing these globally just makes the script easier to use...
var info_cfg;			// info.cfg
var index_list; 		// info.cfg "Index" lines from Index elem
var template;			// Template gump (so it doesn't need to be rebuilt)

program textcmd_Info(who, serial)
	info_cfg := ReadConfigFile(":commands:config/info");
	if ( !info_cfg )
		SendSysMessage(who, "Error reading in info.cfg ->"+info_cfg);
		return 0;
	else
		index_list := GetConfigStringArray(info_cfg["Index"], "Index");
	endif

	var targ := who;
	if ( serial )
		targ := SystemFindObjectBySerial(CInt(serial));
	elseif ( !targ )
		targ := Target(who);
	endif
	if ( !targ.IsA(POLCLASS_MOBILE) )
		//SendSysMessage(who, "Cancelled.");
		//return 0;
		targ := who;
	endif

	template := GumpTemplate(targ);
	var cur_gump := 1;

	while ( 1 )
		cur_gump := GFSendGump(who, BuildGump(targ, cur_gump));
		cur_gump := cur_gump[0];
		if ( !who.connected )
			break;
		elseif ( !cur_gump )
			break;
		endif
	endwhile
endprogram

function BuildGump(targ, index_num)
	var index := index_list[index_num];
	var gump := template;
	var cfg_elem := info_cfg["Index-"+index];
	var groups := GetConfigStringArray(cfg_elem, "Group");
	var y_pos := START_Y;
	foreach group in ( groups )
		var group_elem := info_cfg[group];
		BuildEntries(targ, gump, group_elem, y_pos);
		y_pos := y_pos+5;
		sleepms(2);
	endforeach

	return gump;
endfunction

function BuildEntries(targ, byref gump, byref group_elem, byref y_pos)
	var entries := GetConfigStringArray(group_elem, "Entry");
	if ( group_elem.AutoBox )
		var num_entries := entries.Size();
		GFResizePic(gump, 145, y_pos, GFCfgConst("Defaults", "ForeGround"), 340, (num_entries*20));
	endif

	foreach entry in ( entries )
		entry := SplitWords(entry, " ");
		case ( Lower(entry[1]) )
			"member":
				DisplayMember(targ, gump, entry, y_pos);
				break;
			"vitals":
				DisplayVitals(targ, gump, y_pos);
				break;
			"attributes":
				DisplayAttributes(targ, gump, entry, y_pos);
				break;
			"blank":
				y_pos := y_pos+20;
				break;
			"custom":
				BuildCustomEntry(targ, gump, entry, y_pos);
				break;
			default:
				GFTextLine(gump, 175, y_pos, 32, entry);
				y_pos := y_pos+20;
				break;
		endcase
		sleepms(2);
	endforeach

	return 1;
endfunction

function BuildCustomEntry(targ, byref gump, byref entry, byref y_pos)
	case ( Lower(entry[2]) )
		"Weapon_Speed":
		"Damage_Dice":
		"Average_Damage":
		default:
		break;
	endcase

	return 1;
endfunction

function DisplayMember(targ, byref gump, byref entry, byref y_pos)
	if ( entry[5] )
		GFAddButton(gump, 150, (y_pos+3), 2117, 2118, GF_CLOSE_BTN);
	endif

	GFTextLine(gump, 175, y_pos, 2100, ParseEntryName(entry[2]));

	var value := ParseMembers(targ, entry[3]);
	case ( Lower(entry[4]) )
		"hex":
			value := Hex(value);
			break;
		"binary":
			value := Bin(CInt(value));
			break;
		"script":
			value := GetScriptName(value);
			break;
	endcase
	GFTextRight(gump, 480, y_pos, 2100, value);

	y_pos := y_pos+20;
	return 1;
endfunction

function DisplayVitals(targ, byref gump, byref y_pos)
	var vitals := AP_GetVitalNames();
	var num_vitals := vitals.size();
	GFResizePic(gump, 145, y_pos, GFCfgConst("Defaults", "ForeGround"), 340, (num_vitals*20));
	foreach vital_name in ( vitals )
		GFAddButton(gump, 150, (y_pos+3), 2117, 2118, GF_CLOSE_BTN);
		GFTextLine(gump, 175, y_pos, 2100, vital_name);
		var value := AP_GetVital(targ, vital_name);
		var max_value := AP_GetVitalMaximumValue(targ, vital_name);
		GFTextRight(gump, 480, y_pos, 2100, value+" / "+max_value);
		y_pos := y_pos+20;
		sleepms(2);
	endforeach

	return 1;
endfunction

function DisplayAttributes(targ, byref gump, byref entry, byref y_pos)
	var type := entry[2];
	var attributes := AP_ListAttributesByType(type);
	//
	// Notes about the first page of showing attributes:
	// 1. The Y position they start showing on is dynamic.
	// 2. They may all fit on the first page.
	// 3. The remaining attributes on other pages start on START_Y
	// With this in mind, the array must be broken once for the first page.
	// Then broken again for the remaining pages. Not the most 'efficient' way I suppose.
	//
	
	var y_space := (END_Y-y_pos)+START_Y;
	var available_lines := CInt(y_space / 20);
	var num_attribs := attributes.Size();
	if ( available_lines > num_attribs )
		attributes := array{attributes};
	else
		var page_1 := GetArrayRange(attributes, 1, available_lines);
		var rest := GetArrayRange(attributes, available_lines+1, num_attribs);
		attributes := BreakArray(rest, 20);
		attributes.Insert(1, page_1);
	endif
		
	foreach group in ( attributes )
		num_attribs := group.Size();
		GFResizePic(gump, 145, y_pos, GFCfgConst("Defaults", "ForeGround"), 340, num_attribs * 20);
		if ( _group_iter > 1 )
			GFAddButton(gump, 460, START_Y+5, 2650, 2651, GF_PAGE_BTN, gump.cur_page-1);
		endif
		
		foreach attrib_name in ( group )
			GFAddButton(gump, 150, (y_pos+3), 2117, 2118, GF_CLOSE_BTN);
			GFTextLine(gump, 175, y_pos, 2100, attrib_name);
			var value := AP_GetTrueSkill(targ, attrib_name);
			var mod_value := AP_GetSkillMod(targ, attrib_name);
			GFTextRight(gump, 455, y_pos, 2100, value+" (+"+mod_value+")");
			y_pos := y_pos+20;
			sleepms(2);
		endforeach

		if ( _group_iter < attributes.Size() )
			GFAddButton(gump, 460, 430, 2648, 2649, GF_PAGE_BTN, gump.cur_page+1);
			GFPage(gump, gump.cur_page+1);
			y_pos := START_Y;
		endif

		sleepms(2);
	endforeach

	return 1;
endfunction

function ParseEntryName(entry_name)
	while ( entry_name["_"] )
		entry_name["_"] := " ";
		sleepms(2);
	endwhile
	return entry_name;
endfunction

function ParseMembers(targ, members)
	members := SplitWords(members, ".");
	var result := targ;
	foreach member in ( members )
		var temp := result.Get_Member(member);
		if ( temp != error )
			result := temp;
		else
			result := "None";
			break;
		endif

		sleepms(2);
	endforeach

	return result;
endfunction

function GumpTemplate(targ)
	var gump := GFCreateGump();
	GFPage(gump, 0);
	GFResizePic(gump, 0, 0, GFCfgConst("Defaults", "BackGround"), 500, 480);

	GFResizePic(gump, 15, 15, GFCfgConst("Defaults", "ForeGround"), 470, 35);
	GFTextLine(gump, 25, 22, 2100, "Info on "+targ.name);

	if ( targ.npctemplate )
		GFTextRight(gump, 475, 22, 2100, "[NPC]");
	elseif ( targ.connected )
		GFTextRight(gump, 475, 22, 2100, "[Player]");
	else
		GFTextRight(gump, 475, 22, 2100, "[Offline Player]");
	endif

	GFResizePic(gump, 15, START_Y, GFCfgConst("Defaults", "ForeGround"), 125, END_Y);

	var y_pos := 60;
	foreach entry in ( index_list )
		GFAddButton(gump, 20, (y_pos+3), 2117, 2118, GF_CLOSE_BTN, _entry_iter);
		GFTextLine(gump, 40, y_pos, 2100, entry);
		y_pos := y_pos+20;
		sleepms(2);
	endforeach
	GFPage(gump, 1);

	return gump;
endfunction

function GetScriptName(path)
	if ( !path )
		return "None";
	endif

	while ( path["/"] )
		// Breaks it down to just the file name.
		var pos := Find(path, "/", 1);
		path[1, pos] := "";
		sleepms(2);
	endwhile

	return path;
endfunction
