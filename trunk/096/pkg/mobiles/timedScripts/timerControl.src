use uo;
use os;
use util;
use cfgfile;

include ":timedscripts:timedScripts";

program TimerControl(mobile)
	if ( !mobile.IsA(POLCLASS_MOBILE) )
		mobile := mobile[1];
	endif
	
	// Keep making sure the mobile has this.
	SetObjProperty(mobile, "#TimerControlPID", GetPid());
	
	var num_poisons := 0;
	var timer_list := dictionary;
	StartUp(mobile, timer_list, num_poisons);
	
	while ( mobile.IsA(POLCLASS_MOBILE) )
		/* ^- Will terminate if:
		 * 1. Mobile was an NPC and died.
		 * 2. Was a player character but got deleted.
		 */
		 
		var event := 0;
		if ( timer_list.size() > 0 )
			event := wait_for_event(1);
		else // sleep-mode
			event := wait_for_event(900000);
		endif
		
		mobile.SetPoisoned(num_poisons);
		
		if( event.type == EVENT_ADD_TIMER )
			AddTimer(mobile, event, timer_list, num_poisons);
		elseif( event.type == EVENT_CURE_TIMER )
			CureTimer(mobile, event, timer_list, num_poisons);
		elseif( event.type == EVENT_CURE_SPECIFIC_TIMER )
			//Cure_Specific(mobile, event, timer_list, num_poisons, 1);
		elseif( event.type == EVENT_DEAD )
			//Cure_Death(mobile, timer_list, num_poisons);
		elseif ( event.type == EVENT_LOGOFF )
			LogOff(mobile, timer_list);
			break;
		endif
	endwhile
	
	return 1;
endprogram

function SaveState(mobile, byref timer_list)
	var save_dict := dictionary;
	// Need a new dictionary to save the remaining time
	// Example ( timer.endtime - ReadGameClock() ) == duration
	foreach timer in (timer_list)
		var duration := timer.endtime - ReadGameClock();
		timer.+duration := duration;
		timer.Erase("endtime");
		save_dict[_timer_iter] := timer;
	endforeach
	
	TS_SaveTimerList(mobile, timer_list);
	
	return 1;
endfunction	

function StartUp(mobile, byref timer_list, byref num_poisons)
	// The controller just started. 
	// Take in any timers in the dictionary and start the scripts.
	var temp_list := TS_GetTimerList(mobile); // Will initialize dictionary.
	
	foreach timer in (temp_list)
		var event := struct;
		event.+name := _timer_iter;
		event.+amount := timer.duration;
		event.+level := timer.level;

		AddTimer(mobile, event, timer_list, num_poisons);
		sleepms(2);
	endforeach
	
	return 1;
endfunction

function LogOff(mobile, byref timer_list)
	//On Logout, save the status of timers. Then stop the scripts.
	
	Set_Critical(1);
	SaveState(mobile, timer_list);
	
	foreach timer in ( timer_list )
		timer := timer; // So the compiler doesn't warn.
		var elem_info := TS_GetCfgElem(_timer_iter);
		KillTimedScript(timer_list.pid, timer_list, _timer_iter);

		if( elem_info.LogOffScript )
			var script := start_script(elem_info.LogOffScript, {mobile});
			if( script.errortext )
				Print("Error::LogOff() - ["+elem_info.LogOffScript+"] "+script.errortext);
			endif
		endif
	endforeach
	Set_Critical(0);
	
	return 1;
endfunction

function AddTimer(mobile, byref event, byref timer_list, byref num_poisons)
	// Check if a poison exists. If it does, increase its duration.
	// If it does not exist, add it to the list on the mobile. 
	// Start the necessary script and store the name, duration and sub-script pid.
	
	if( !TS_GetCfgElem(event.name) )
		SysLog("Error::AddTimer() - "+event.name+" not found in timedScripts.cfg");
		return 0;
	endif
	
	var result := 0;
	if ( !timer_list.Exists(event.name) )
		result := AddNewTimer(mobile, event, timer_list, num_poisons);
	else
		result := AddExistingTimer(mobile, event, timer_list, num_poisons);
	endif
	
	if ( result )
		SaveState(mobile, timer_list);
	endif
	
	return 1;
endfunction

function AddNewTimer(mobile, byref event, byref timer_list, byref num_poisons)
	var elem_info := TS_GetCfgElem(event.name);
	
	var script := start_script(elem_info.Script, {mobile, event.attacker, event.level});
	if( script.errortext )
		SysLog("Error::AddNewTimer() - Unable to start script ["+elem_info.Script+"] ->"+script.errortext);
		return 0;
	endif
	
	var maxdur := CInt(elem_info.MaxDuration);
	event.amount := CInt(event.amount);
	if ( maxdur > 0 )
		if ( event.amount > maxdur )
			event.amount := maxdur;
		endif
	endif

	timer_list[event.name] := struct;
	// .endtime is used instead of .duration now to ensure more accurate time keeping.
	timer_list[event.name].+endtime := ReadGameClock()+event.amount;
	timer_list[event.name].+pid := script.pid;
	timer_list[event.name].+level := CInt(event.level);
	
	if( elem_info.IndicatePoison )
		num_poisons := num_poisons+1;
	endif
	
	return 1;
endfunction

function AddExistingTimer(mobile, byref event, byref timer_list, byref num_poisons)
	var elem_info := TS_GetCfgElem(event.name);
	
	var level := CInt(timer_list[event.name].level);
	var amt := CInt(event.amount);
	
	var end_time := timer_list[event.name].endtime;
	var duration := end_time - ReadGameClock();
	
	event.amount := CInt(event.amount);
	if ( elem_info.Cumulative )
		if ( (event.level) && level )
			amt := CInt(CDbl(amt) * (CDbl(event.level) / CDbl(timer_list[event.name].level)));
			if ( level >= event.level )
				event.amount := duration + amt;
			else
				KillTimedScript(timer_list[event.name].pid, timer_list, event.name);
				event.amount := amt;
				AddTimer(mobile, event, timer_list, num_poisons);
				return 1;
			endif
		else
			event.amount := (duration + amt);
		endif
	else
		if ( (event.level) && level )
			if ( (level == event.level) && (amt > duration) )
				event.amount := amt;
			elseif ( event.level > level )
				KillTimedScript(timer_list[event.name].pid, timer_list, event.name);
				event.amount := amt;
				AddTimer(mobile, event, timer_list, num_poisons);
				return 1;
			endif					
		else
			if ( amt > duration )
				event.amount := amt;
			endif
		endif
	endif
	
	var maxdur := CInt(elem_info.MaxDuration);
	if ( maxdur > 0 )
		if ( (duration+event.amount) > maxdur )
			duration := maxdur;
		else
			duration := duration+event.amount;
		endif
	endif
	
	timer_list[event.name].endtime := ReadGameClock()+duration;
	
	return 1;
endfunction

function CureTimer(mobile, byref event, byref timer_list, byref num_poisons)
	//Run through all curable poisons, and keep curing until it runs out of curing power.

	var cure_type := Lower(event.curetype);
	foreach timer in ( timer_list )
		var elem_info := TS_GetCfgElem(_timer_iter);
		if ( !elem_info.NoCure ) // Its curable
			if ( !cure_type || cure_type == Lower(elem_info.Type) )
				event.name := _timer_iter;
				LowerDuration(mobile, event, timer_list, num_poisons);
			endif

			if( event.amount <= 0 ) // All out of cure power
				break;
			endif
			sleepms(2);
		endif
	endforeach
endfunction

function LowerDuration(mobile, byref event, byref timer_list, byref num_poisons)
	return 1;
endfunction

function EndTimedScript(mobile, timer_name, byref num_poisons)
	var cfg_elem := TS_GetCfgElem(timer_name);
	
	if( cfg_elem.IndicatePoison )
		num_poisons := num_poisons-1;
	endif

	if( cfg_elem.EndMessage )
		SendSysMessage(mobile, elem.EndMessage);
	endif

	if( PW_CfgInfo(poison_name).CureScript )
		var script := start_script(elem_info.EndScript, {mobile});
		if( script.errortext )
			SysLog("Error::EndTimedScript() - "+script.errortext);
		endif
	endif
endfunction

function KillTimedScript(byref pid, byref timer_list, timer_name)
	var script := GetProcess(pid);
	script.kill();
	timer_list.Erase(timer_name);
	
	return 1;
endfunction
