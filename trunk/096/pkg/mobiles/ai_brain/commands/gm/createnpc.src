use uo;
use os;

include ":datafile:include/datafile";
include ":gumps:include/gumps";
include ":gumps:include/gumps_ex";

const UNCACHE_BTN	:= 0xF000000;
const DEFAULT_CATEGORY	:= "None";

var data_file := DFOpenDataFile(":ai_brain:createnpc", DF_CREATE);

program MakeNPC(who, template)
	if ( !template )
		template := SelectTemplateFromGump(who);
		if ( !template )
			return 0;
		endif
	endif
	
	var targ := TargetCoordinates(who);
	if ( !targ )
		SendSysMessage(who, "Cancelled");
		return 0;
	endif

	var npc := CreateNPCFromTemplate(template, targ.x, targ.y, targ.z, 0, who.realm);
	npc.facing := who.facing;
	if ( npc.errortext )
		SendSysMessage(who, "Error creating NPC ["+template+"] -> "+npc.errortext);
		return 0;
	endif
endprogram

function SelectTemplateFromGump(who)
	var input := GFSendGump(who, RetrieveGump("Index"));
	if ( !input )
		SendSysMessage(who, "Cancelled");
		return 0;
	elseif ( input[UNCACHE_BTN] )
		foreach elem_name in DFGetElemNames(data_file)
			data_file.DeleteElement(elem_name);
			sleepms(2);
		endforeach
		
		SendSysMessage(who, "All createnpc data uncached.");
		return 0;
	endif
		
	var category_names := GetCategoryNames();
	input := GFSendGump(who, BuildNPCGump(category_names[input[0]]));
	if ( !input )
		SendSysMessage(who, "Cancelled");
		return 0;
	endif
	
	var elem_names := GetConfigStringKeys(ReadConfigFile("::npcdesc"));
	return elem_names[input[0]];
endfunction

function RetrieveGump(category_name)
	if ( category_name == "Index" )
		var data_elem := DFFindElement(data_file, "Index");
		var gump := data_elem.GetProp("Gump");
		if ( !gump )
			gump := BuildIndexGump();
		endif
		
		return gump;
	else
		var data_elem := DFFindElement(data_file, category_name);
		var gump := data_elem.GetProp("Gump");
		if ( !gump )
			gump := BuildNPCGump(category_name);
		endif
		
		return gump;
	endif
endfunction

function GetCategoryNames()
	var data_elem := DFFindElement(data_file, "Index");
	var category_names := data_elem.GetProp("CategoryNames");
	if ( !category_names )
		category_names := SetupCategoryNames();
	endif
	
	return category_names;
endfunction

function SetupCategoryNames()
	var category_names := (SortNPCs().keys());
	var data_elem := DFFindElement(data_file, "Index", DF_CREATE);
	data_elem.SetProp("CategoryNames", category_names);
	
	return category_names;
endfunction

function BuildIndexGump()
	Set_Priority(100);
	var category_names := GetCategoryNames();
	
	var data_elem := DFFindElement(data_file, "Index", DF_CREATE);
	data_elem.SetProp("CategoryNames", category_names);
	
	var bkgnd_silvertrim := GFCfgConst("BackGrounds", "SILVERTRIM");
	var bkgnd_dark_stone := GFCfgConst("BackGrounds", "DARK_STONE");
	
	var gump := GFCreateGump();
	GFPage(gump, 0);
	GFResizePic(gump, 0, 0, bkgnd_silvertrim, 300, 480);
	GFResizePic(gump, 10, 10, bkgnd_dark_stone, 280, 460);
	var y_pos := 40;
	var counter := 1;
	var page_num := 1;
	GFTextMid(gump, 10, 15, 280, 2100, "NPC Categories");
	
	/////
	GFAddButton(gump, 158, 445, 4002, 4003, GF_CLOSE_BTN, UNCACHE_BTN);
	GFTextLine(gump, 193, 445, 2100, "Uncache data");
	/////
	
	GFPage(gump, page_num);
	foreach category_name in (category_names)
		GFAddButton(gump, 20, y_pos+3, 2117, 2118, GF_CLOSE_BTN, (_category_name_iter));
		GFTextLine(gump, 40, y_pos, 2100, category_name);
		y_pos := y_pos+20;
		counter := counter+1;
		
		if ( counter > 20 )
			counter := 1;
			y_pos := 40;
			GFAddButton(gump, 265, 445, 2648, 2649, GF_PAGE_BTN, page_num+1);
			page_num := page_num+1;
			GFPage(gump, page_num);
			GFAddButton(gump, 265, 15, 2650, 2651, GF_PAGE_BTN, page_num-1);
		endif
		sleepms(2);
	endforeach
	data_elem.SetProp("Gump", gump);
	
	return gump;
endfunction

function BuildNPCGump(category_name)
	Set_Priority(100);
	
	var npc_list := SortNPCs();
	if ( !npc_list.Exists(category_name) )
		//Nifty new trick below.
		return error{"errortext":="Category name does not exist."};
	endif
	
	var data_elem := DFFindElement(data_file, Lower(category_name), DF_CREATE);	
	npc_list := npc_list[category_name];

	var bkgnd_silvertrim := GFCfgConst("BackGrounds", "SILVERTRIM");
	var bkgnd_dark_stone := GFCfgConst("BackGrounds", "DARK_STONE");
	
	var gump := GFCreateGump();
	GFPage(gump, 0);
	GFResizePic(gump, 0, 0, bkgnd_silvertrim, 300, 480);
	GFResizePic(gump, 10, 10, bkgnd_dark_stone, 280, 460);
	var y_pos := 40;
	var counter := 1;
	var page_num := 1;
	GFTextMid(gump, 10, 15, 280, 2100, "NPC List - "+category_name);
	GFPage(gump, page_num);
	foreach template in (npc_list[category_name])
		GFAddButton(gump, 20, y_pos+3, 2117, 2118, GF_CLOSE_BTN, template.pos);
		GFTextLine(gump, 40, y_pos, template.color, template.name);
		y_pos := y_pos+20;
		counter := counter+1;

		if ( counter > 21 )
			counter := 1;
			y_pos := 40;
			GFAddButton(gump, 265, 445, 2648, 2649, GF_PAGE_BTN, page_num+1);
			page_num := page_num+1;
			GFPage(gump, page_num);
			GFAddButton(gump, 265, 15, 2650, 2651, GF_PAGE_BTN, page_num-1);
		endif
		sleepms(2);
	endforeach
	data_elem.SetProp("Gump", gump);
	
	return gump;
endfunction

function SortNPCs()
	var data_elem := DFFindElement(data_file, "Index", DF_CREATE);
	var categories :=  data_elem.GetProp("NPCListSorted");
	if ( categories )
		return categories;
	endif
		
	var npc_config := ReadConfigFile("::npcdesc");
	var cfg_keys := GetConfigStringKeys(npc_config);

	categories := dictionary;
	categories[DEFAULT_CATEGORY] := array{};

	foreach template_name in (cfg_keys)
		var cfg_elem := npc_config[template_name];
		var template := struct;
		template.+name :=template_name;
		template.+pos :=_template_name_iter;
		template.+color :=GetNameColor(npc_config[template_name].alignment);

		if ( !cfg_elem.category )
			categories[DEFAULT_CATEGORY].append(template);
		else
			if ( Lower(TypeOf(categories[cfg_elem.category])) != "array" )
				categories[cfg_elem.category] := array{};
			endif

			categories[cfg_elem.category].append(template);
		endif
		sleepms(2);
	endforeach
	
	// This function is time consuming.. so its results get saved.	
	data_elem.SetProp("NPCListSorted", categories);

	return categories;
endfunction

function GetNameColor(reputation)
	var reputation_cfg := ReadConfigFile("::repsys");
	//We know the config is there - core won't start without it.
	var reputation_elem := reputation_cfg["NameColoring"];
	if ( !reputation_elem )
		/*
		 * In most shards the config is setup as
		 * NameColoring
		 * {
		 * // Information here
		 * }
		 * **---=[! Needs to be changed to !]=---**
		 * NameColoring NameColoring
		 * {
		 * //Information here
		 * }
		 */
		SysLog("Unable to read in repsys.cfg elem [NameColoring] ->"+reputation_elem.errortext);
		SysLog("You probably don't have an elem name set for it. Thats naughty!");
		return 0;
	endif
	
	case ( reputation )
		"good":		return (GetConfigInt(reputation_elem, "innocent")-1);
		"neutral":	return (GetConfigInt(reputation_elem, "attackable")-1);
		"evil":		return (GetConfigInt(reputation_elem, "murderer")-1);
		 // No alignment for an npc is considered neutral
		default: 	return (GetConfigInt(reputation_elem, "attackable")-1);
	endcase
endfunction
